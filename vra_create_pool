#!/usr/bin/env ruby


require 'resolv'
require 'optparse'
require 'yaml'
require_relative 'vra_create'
require 'kitchen/driver/vmpool_stores/gitlab_store'
require 'socket'
require 'timeout'

include VraUtilities

# @return [Hash] - hash of config options
# reads from vmpool_config.yaml file if exists
def options
  @options ||= begin
    opts = File.exist?('vmpool_config.yaml') ? YAML.load_file('vmpool_config.yaml') : {}
  end
end

def create_pool(pool_data)
  (1..pool_data['instances']).map {|num| submit_new_request(pool_data['payload_file']).id }
end

# return hostnames or false
def resolve_vm_name(request)
  r = client.requests.by_id(request)
  return r.resources.map(&:name) if r.successful? and r.completed?
  return false
end

# @return [Hash] - a store hash that contains one or more pools
# @option project_id [Integer] - the project id in gitlab
# @option snippet_id [Integer] - the snipppet id in the gitlab project
# @option pool_file [String] - the snipppet file name
def store(store_options = options)
  # create a new instance of the store with the provided options
  @store ||= Kitchen::Driver::VmpoolStores::GitlabStore.new(store_options)
end

# creates the number of instances defined in the pool data
def create_pools
  pools.map do |key, value|
    # convert the requests to vm names
    pools[key]['requests'] = value['requests'].find_all do |req|
       if hostnames = resolve_vm_name(req)
         pools[key]['pool_instances'] = value['pool_instances'] + hostnames
         false
       else
         req
       end
    end

    # return the alive instances and save to the pool
    pools[key]['pool_instances'] = pools[key]['pool_instances'].find_all {|h| is_alive?(h) }

    # create the pool, and save the request in the requests
    # do not create if the number of systems and requests are more than the requested amount
    current_total = value['pool_instances'].count + pools[key]['requests'].count
    unless current_total >= value['instances']
      reqs = create_pool(value)
      pools[key]['requests'] = reqs
    end
  end
  store.save
end

# @return [Boolean] - true if the host is alive and listening
def is_alive?(node)
  has_dns_record?(node) && ssh_is_alive?(node)
end

# @return [Boolean] - true if the host is listening on 22, false otherwise
def ssh_is_alive?(node)
  puts "Checking if #{node} has ssh alive"
  begin
      Timeout::timeout(3) { TCPSocket.new(node, 22) }
      puts "Responded!!"
      return true
  rescue Errno::ECONNREFUSED
       puts "Connection refused"
      return false
  rescue SocketError
      puts "No connection!!"
      return false
  rescue Timeout::Error
      puts "No connection, timed out!!"
      return false
  end
end

# @return [Boolean] - true if the host is still in dns, false otherwise
def has_dns_record?(node)
  begin
    result = Resolv.getaddress(node)
  rescue Resolv::ResolvError
    result = false
  end
  result
end

# @return [Hash] - returns a hash of all the pools
def pools
   @pools ||= store.pool_data
end

# @return [Boolean] - true if options are valid
def valid_options?
  options['project_id'].to_i > 0 &&
  options['snippet_id'].to_i > 0
end

## main entry point

OptionParser.new do |opts|
  opts.program_name = 'create-pool'
  opts.on_head(<<-EOF

Summary: A tool used to create a pool of vra systems

  Example:
     #{__FILE__} -f pool_file.yaml -p 33 -s 103

  If you wish to store the config in a file, this script will read vmpool_config.yaml
  for the same configs.

  EOF
  )
  opts.on('-f', '--pool-file FILE', "Create the pools found in the given pool file") do |c|
    options['pool_file'] = c
  end
  opts.on('-p', '--project-id ID', "The gitlab project id") do |c|
    options['project_id'] = c.to_i
  end
  opts.on('-s', '--snippet-id ID', "The gitlab project snippet id") do |c|
    options['snippet_id'] = c.to_i
  end

end.parse!


if valid_options?
  create_pools
else
  puts "Invalid options: #{options.inspect}"
  exit 1
end
